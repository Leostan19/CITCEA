'''
PV pyomo block.
It includes performance characteristics and costs calculation. PV size can be optimized or fixed.
'''

import pyomo.environ as pyo
import math


def PV_block(model, l_PV, l_t, AllInputs):
    """
    PV system.

    It can include different PV panel models, which will be trated as different subsystems.
    Each PV subsystem is composed by an amount of existing capacity and can be expanded.
    The capacity expansion can also be fixed.
    This model includes performance characteristics and costs calculation, as well as a sizing limitation.

    This is a LP model.

    :param model: pyomo ``Block()`` or ``Model()`` in which the PV system is added
    :param l_PV: ``list`` containing all PV subsystems id
    :param l_t: ``list`` containing all time-steps
    :param AllInputs: data class

    Pyomo parameters:
        - :math:`DNI`
        - PV_DNI_rating: ratio between installed power and surface used [kW/m2], for each PV subsystem
        - PV_Surface: available surface for PV [m2]
        - PV_Forecast: PV forecast (generation capacity by kWp installed) [pu], for each subsystem and time-step
        - PV_G0: existing installed power [kWp], for each subsystem
        - PV_c_capex: unitary capital cost [€/kW], for each subsystem
        - PV_c_opex: unitary operation and maintenance cost [€/(kW*year)], for each subsystem
        - PV_c_replacement: unitary replacement cost [€/kW], for each subsystem
        - PV_n_replacement: number of times the PV has to be replaced during the project lifetime, for each subsystem
        - PV_c_incentives: unitary economic incentives on the PV CAPEX [€/kW], for each subsystem
        - PV_fix_G: PV installed capacity (to add) if it is fixed [kWp], for each subsystem
    Pyomo variables:
        - PV_G: PV installed capacity (to add) [kWp], for each subsystem
        - PV_P: power generated by PV [kW], for each subsystem and time-step
        - PV_C_capex: total PV CAPEX [€]
        - PV_C_incentives: total incentives on PV CAPEX [€]
        - PV_C_opex: total annual PV OPEX [€]
        - PV_C_replacement: total cost of PV replacement during the project lifetime [€]
    Pyomo constraints:
        - the surface used by PV (considering both new and existent, and all PV subsystems) has to be lower than the available surface for that resource
        - generated power depends on the installed capacity and the availability of the resource
        - ... ESCRIBIR VARIABLES Y PARAMETROS EN FORMATO MATEMATICO, Y AQUÍ PONER LA DESCRIPCIÓN DE LAS RESTRICCIONES Y SUS ECUACIONES

    Block inputs: -

    Block outputs: PV_G, PV_P, PV_C_capex, PV_C_incentives, PV_C_opex, PV_C_replacement
    """

    ##### Model Sets #####

    # model.t = pyo.Set(initialize=l_t)  # time steps to consider in the optimization (time horizon=365 days)
    # model.i_PV = pyo.Set(initialize=l_PV)  # models/elements of PV


    ##### Model Parameters #####

    model.PV_DNI_rating = pyo.Param(model.i_PV, initialize=AllInputs.PV.DNI,
                                    within=pyo.NonNegativeReals)  # ratio between installed power and surface used [kW/m2]
    model.PV_Surface = pyo.Param(initialize=AllInputs.PV.available_surface,
                                 within=pyo.NonNegativeReals)  # available surface for PV [m2]
    model.PV_Forecast = pyo.Param(model.i_PV, model.t, initialize=AllInputs.PV.forecast,
                                  within=pyo.NonNegativeReals)  # PV forecast (generation capacity by kWp installed) [pu]
    model.PV_G0 = pyo.Param(model.i_PV, initialize=AllInputs.PV.existent_kW,
                            within=pyo.NonNegativeReals)  # installed power already in the system [kW]
    model.PV_c_capex = pyo.Param(model.i_PV, initialize=AllInputs.PV.capital, within=pyo.NonNegativeReals)  # capital cost [€/kW]
    model.PV_c_opex = pyo.Param(model.i_PV, initialize=AllInputs.PV.om,
                                within=pyo.NonNegativeReals)  # operation and maintenance cost [€/(kW*year)]
    model.PV_c_replacement = pyo.Param(model.i_PV, initialize=AllInputs.PV.replacement,
                                       within=pyo.NonNegativeReals)  # replacement cost [€/kW]
    # PV_n_r = {i_PV: math.ceil(AllInputs.System.lifetime / AllInputs.PV.lifetime[i_PV]) - 1 for i_PV in l_PV}
    # model.PV_n_replacement = pyo.Param(model.i_PV, initialize=PV_n_r)  # number of times the PV system has to be replaced during the project lifetime
    model.PV_c_incentives = pyo.Param(model.i_PV, initialize=AllInputs.PV.capex_incentives,
                                      within=pyo.NonNegativeReals)  # economic incentives on the PV CAPEX [€/kW]
    model.PV_fix_G = pyo.Param(model.i_PV, initialize=AllInputs.PV.fix_kW, within=pyo.Any)  # PV installed capacity (to add) if it is fixed [kW]
    model.PV_pos_bus = pyo.Param(model.i_PV, model.i_bus, initialize=AllInputs.PV.pos_bus, within=pyo.Binary)  # binary that indicates the bus to which the PV is connected --> [id_load,id_bus]=1

    ##### Model Variables #####

    model.PV_G = pyo.Var(model.i_PV, within=pyo.NonNegativeReals)  # PV installed capacity (to add) [kW]
    model.PV_P = pyo.Var(model.i_PV, model.t, within=pyo.NonNegativeReals)  # power generated by PV at each time-step [kW]
    #
    model.PV_C_capex = pyo.Var(model.i_PV, within=pyo.NonNegativeReals)  # total PV CAPEX [€]
    model.PV_C_incentives = pyo.Var(model.i_PV, within=pyo.NonNegativeReals)  # total incentives for PV [€]
    model.PV_C_opex = pyo.Var(model.i_PV, within=pyo.NonNegativeReals)  # total annual PV OPEX [€]
    model.PV_C_replacement1 = pyo.Var(model.i_PV, within=pyo.NonNegativeReals)  # total cost of PV replacement in 1 year [€]
    model.PV_C_replacement = pyo.Var(model.i_PV, within=pyo.NonNegativeReals)  # total cost of PV replacement during the project lifetime [€]


    ##### Model Constraints #####

    def Constraint_PV_max_surface(m):
        """
        Constraint: the surface used by PV (considering both new and existent, and all PV models)
        has to be lower than the available surface for that resource
        :param m: Pyomo optimization model
        :return: expression of the constraint
        """
        if not l_PV:
            return pyo.Constraint.Skip
        else:
            return sum((m.PV_G[i_PV] + m.PV_G0[i_PV]) / m.PV_DNI_rating[i_PV] for i_PV in l_PV) <= m.PV_Surface
    model.Constr_PV_max_surface = pyo.Constraint(rule=Constraint_PV_max_surface)

    def Constraint_PV_generation(m, i_PV, t):
        """
        Constraint: generated power depends on the installed capacity and the availability of the resource
        :param m: Pyomo optimization model
        :param i_PV: PV model or subsystem index
        :param t: time-step index
        :return: expression of the constraint for every t and i_PV
        """
        return m.PV_P[i_PV, t] <= (m.PV_G[i_PV] + m.PV_G0[i_PV]) * m.PV_Forecast[i_PV, t]
    model.Constr_PV_generation = pyo.Constraint(model.i_PV, model.t, rule=Constraint_PV_generation)

    def Calculate_PV_C_capex(m, i_PV):
        """
        Constraint: total PV CAPEX is calculated multiplying the unitary cost and the installed power (to add)
        :param m: Pyomo optimization model
        :param i_PV: PV model or subsystem index
        :return: expression of the constraint for every i_PV
        """
        return m.PV_C_capex[i_PV] == m.PV_c_capex[i_PV] * m.PV_G[i_PV]
    model.Constr_PV_C_capex = pyo.Constraint(model.i_PV, rule=Calculate_PV_C_capex)

    def Calculate_PV_C_incentives(m, i_PV):
        """
        Constraint: total incentices for PV is calculated multiplying the unitary incentives and the installed power (to add)
        :param m: Pyomo optimization model
        :param i_PV: PV model or subsystem index
        :return: expression of the constraint for every i_PV
        """
        return m.PV_C_incentives[i_PV] == m.PV_c_incentives[i_PV] * m.PV_G[i_PV]
    model.Constr_PV_C_incentives = pyo.Constraint(model.i_PV, rule=Calculate_PV_C_incentives)

    def Calculate_PV_C_opex_anual(m, i_PV):
        """
        Constraint: total PV OPEX is calculated multiplying the unitary cost and the installed power (considering both new and existent)
        :param m: Pyomo optimization model
        :param i_PV: PV model or subsystem index
        :return: expression of the constraint for every i_PV
        """
        return m.PV_C_opex[i_PV] == m.PV_c_opex[i_PV] * (m.PV_G[i_PV] + m.PV_G0[i_PV])  # fixed opex cost
    model.Constr_PV_C_opex_anual = pyo.Constraint(model.i_PV, rule=Calculate_PV_C_opex_anual)

    def Calculate_PV_C_replacement1(m, i_PV):
        """
        Constraint: total annual PV replacement cost is calculated multiplying the unitary cost and the installed power
        (considering both new and existent, supposing existent capacity is replaced at the same time as the new one)
        :param m: Pyomo optimization model
        :param i_PV: PV model or subsystem index
        :return: expression of the constraint for every i_PV
        """
        return m.PV_C_replacement1[i_PV] == m.PV_c_replacement[i_PV] * (m.PV_G[i_PV] + m.PV_G0[i_PV])
    model.Constr_PV_C_replacement1 = pyo.Constraint(model.i_PV, rule=Calculate_PV_C_replacement1)
    def Calculate_PV_C_replacement(m, i_PV):
        """
        Constraint: total PV replacement cost is calculated as the NPC of the annual replacement cost
        :param m: Pyomo optimization model
        :param i_PV: PV model or subsystem index
        :return: expression of the constraint for every i_PV
        """
        # m.PV_C_replacement[i_PV] == m.PV_C_replacement1[i_PV] * m.PV_n_replacement[i_PV]
        return m.PV_C_replacement[i_PV] == sum(m.PV_C_replacement1[i_PV]/(1+m.discount_rate)**y
                                               for y in range(AllInputs.PV.lifetime[i_PV], AllInputs.System.lifetime, AllInputs.PV.lifetime[i_PV]))
    model.Constr_PV_C_replacement = pyo.Constraint(model.i_PV, rule=Calculate_PV_C_replacement)

    def Constraint_PV_fix_G(m, i_PV):
        """
        Constraint: if a subsystem is set as non-expandable or the aim is to perform an operation optimization,
        the PV installed power (to add) is fixed to a certain value
        :param m: Pyomo optimization model
        :param i_PV: PV model or subsystem index
        :return: expression of the constraint for every i_PV
        """
        if AllInputs.PV.sizing[i_PV] == 0:
            return m.PV_G[i_PV] == m.PV_fix_G[i_PV]
        else:
            return pyo.Constraint.Skip
    model.Constr_PV_fix_G = pyo.Constraint(model.i_PV, rule=Constraint_PV_fix_G)
